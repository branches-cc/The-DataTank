<?php

/**
 * Executes the DataGrouper "filter"
 * 
 * @package The-Datatank/universalfilter/interpreter/executers
 * @copyright (C) 2012 We Open Data
 * @license AGPLv3
 * @author Jeroen Penninck
 */
class DataGrouperExecuter extends UniversalFilterNodeExecuter  {
    // getColumns
    
    public function execute(UniversalFilterNode $filter, IInterpreter $interpreter) {
        //get source environment
        $executer = $interpreter->findExecuterFor($filter->getSource());
        $environment = $executer->execute($filter->getSource(), $interpreter);
        
        //the table generated by the last executer
        $sourcetable = $environment->getTable();
        
        //get the columns to group
        $columnIdentifiers = $filter->getColumns();
        
        
        // make the new header
        $oldHeader = $sourcetable->getHeader();
        $newColumns = array();
        
        
        
        for ($index = 0; $index < $oldHeader->getColumnCount(); $index++) {
            $oldColumnInfo = $oldHeader->getColumnInformationById($oldHeader->getColumnIdByIndex($index));
            
            $needToBeGrouped=true;
            for ($columnNameIndex = 0; $columnNameIndex < count($columnIdentifiers); $columnNameIndex++) {
                $columnIdentifier = $columnIdentifiers[$columnNameIndex]->getIdentifierString();
                if($oldColumnInfo->matchName(explode(".", $columnIdentifier))){
                    $needToBeGrouped=false;
                }
            }
            
            $newColumnInfo=null;
            if($needToBeGrouped){
                $newColumnInfo = $oldColumnInfo->cloneColumnGrouped();
            }else{
                $newColumnInfo = $oldColumnInfo->cloneColumnNewId();
            }
            array_push($newColumns, $newColumnInfo);
        }
        
        $newHeader = new UniversalFilterTableHeader($newColumns, false, false);
        
        // new header is generated....
        
        
        //
        // now Group!
        //
        
        $bigListOfGroups = new BigList();
        $bigGroupMap = new BigMap();//of hashkey => array of indices in the rows of the source table that match the description

        //loop through all rows and check if they are in the map
        for ($index = 0; $index < $sourcetable->getContent()->getRowCount(); $index++) {
            $oldRow = $sourcetable->getContent()->getRow($index);
            $hash = "";
             for ($cindex = 0; $cindex < $oldHeader->getColumnCount(); $cindex++) {
                 $oldId = $oldHeader->getColumnIdByIndex($cindex);
                 $newColumn = $newColumns[$cindex];
                 $newId = $newColumn->getId();
                 $isGrouped = $newColumn->isGrouped();
                 
                 if(!$isGrouped){
                     //add to hash
                     $hash.=$oldRow->getHashForField($oldId)."%";//% is separator
                 }
             }
             if(!$bigGroupMap->containsMapValue($hash)){
                 $bigGroupMap->setMapValue($hash, array());
                 $bigListOfGroups->addItem($hash);
             }
             
             // add the index of the row to the map
             $oldArray = $bigGroupMap->getMapValue($hash);
             array_push($oldArray, $index);
             $bigGroupMap->setMapValue($hash, $oldArray);
        }
        
        
        //
        // grouping done, now create the content
        //
        $newRows = new UniversalFilterTableContent();
        
        for ($index = 0; $index < $bigListOfGroups->getSize(); $index++) {// FOR ALL GROUPS
            $hash = $bigListOfGroups->getIndex($index);
            $group = $bigGroupMap->getMapValue($hash);
            
            $newRow = new UniversalFilterTableContentRow();
            $groupedColumnValues = array();
            
            foreach ($group as $groupIndex => $value) {// A ROW IN THE GROUP
                $oldRow = $sourcetable->getContent()->getRow($value);
                
                for ($cindex = 0; $cindex < $oldHeader->getColumnCount(); $cindex++) {//A COLUMN IN A ROW IN THE GROUP
                    $oldId = $oldHeader->getColumnIdByIndex($cindex);
                    $newColumn = $newColumns[$cindex];
                    $newId = $newColumn->getId();
                    $isGrouped = $newColumn->isGrouped();
                    
                    $value = $oldRow->getCellValue($oldId);
                    
                    if($isGrouped){
                        $arr=array();
                        
                        if(isset($groupedColumnValues[$newId])){
                            $arr = $groupedColumnValues[$newId];
                        }
                        
                        array_push($arr, $value);
                        $groupedColumnValues[$newId]=$arr;
                    }else{
                        //just set the value
                        $groupedColumnValues[$newId]=$value;
                    }
                }
                
            }
            
            // NOW CREATE THE ROW
            for ($cindex = 0; $cindex < $oldHeader->getColumnCount(); $cindex++) {//A COLUMN IN THE GROUP
                $newColumn = $newColumns[$cindex];
                $newId = $newColumn->getId();
                $isGrouped = $newColumn->isGrouped();

                if($isGrouped){
                    $newRow->defineGroupedValue($newId, $groupedColumnValues[$newId]);
                }else{
                    $newRow->defineValue($newId, $groupedColumnValues[$newId]);
                }
            }
            
            $newRows->addRow($newRow);
        }
        
        //the new table
        $newtable = new UniversalFilterTable($newHeader, $newRows);
        
        //add it to the environment
        $environment->setTable($newtable);
        
        return $environment;
    }
}

?>
