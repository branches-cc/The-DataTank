%class spectql
%start stmt

%left ':'
%left '.'
%left '?'
%left LN
%left '&'
%left '|'
%left '+' '-'
%left '*' '/'
%left '>' EQ '<' '~'

stmt = flow
| flow ':' format
.

flow = expression
| expression/e '.' name/function '(' num/n1 ')' { if($function == "limit"){ /* TODO */ $$ = null;}else{ $$ = createAggregatorFilter($function,$n1);/* TODO create function php file to map constants*/  } }
.

expression = resource {$$ = $1;}
| calc { /* TODO execute calculation */ $$ = $1->execute(); }
.
resource = resourceid '{' selector/sel '}' { $columns = new ColumnSelectionFilter($sel["filters"]); 
                                             $columns->setSource(new Identifier($1)); /* $sorts = new SORTOBJECT(); 
                                             $sort->setSource($columns); $$ = $sorts;*/ $$ = $columns; }
|resourceid '{' selector/sel '}' '?' filterlist/fl { $expressionFilter = new FilterByExpressionFilter($fl); 
                                                     $columns = new ColumnSelectionFilter($sel["filters"]); 
                                                     $columns->setSource($expressionFilter); $expressionFilter->setSource(new Identifier($1)); 
                                                     /* $sorts = new SORTOBJECT(); $sort->setSource($columns); $$ = $sorts;*/ $$ = $columns; }
| resourceid { $$ = new Identifier($1); }
| resourceid '?' filterlist { $$ = new FilterByExpressionFilter($3); $$->setSource(new Identifier($1)); }
.

resourceid = name '/' name  { $$ = $1 . "." . $3; }
| resourceid '/' name { $$ = $1 . "." . $3; }
| resourceid '/' num { $$ = $1 . "." . $3; }
.

name = name '-' name { $$ = $1 . "-" . $3; }
|
.

num = num '.' num { $$ = new Constant((double) ($1 . "." . $3));  }
|
.

filterlist = filter { $$ = $1; }
| filterlist '&' filterlist { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_AND,$1,$3); }
| filterlist '|' filterlist { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_OR,$1,$3); }
| '(' filterlist/list ')' { $$ = $list;}
.

filter = name/a '>' string/b { $$ =  new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_SMALLER_THAN, new Identifier($a),new Constant($b)); }
| name/a EQ string/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_EQUAL,new Identifier($a),new Constant($b)); }
| name/a '<' string/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_SMALLER_THAN, new Identifier($a),new Constant($b)); }
| name/a '>' num/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_LARGER_THAN, new Identifier($a),new Constant($b)); }
| name/a EQ num/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_EQUAL,new Identifier($a),new Constant($b)); }
| name/a '<' num/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_SMALLER_THAN, new Identifier($a),new Constant($b)); }
| name/a '~' string/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_MATCH_REGEX, new Identifier($a),new Constant("/.*".preg_quote($b).".*/")); }
| name/a NE string/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_NOTEQUAL,new Identifier($a),new Constant($b)); }
| name/a NE num/b    { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_NOTEQUAL,new Identifier($a),new Constant($b)); }
| name/a GE string/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_LARGER_OR_EQUAL_THAN,new Identifier($a),new Constant($b)); }
| name/a GE num/b    { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_LARGER_OR_EQUAL_THAN,new Identifier($a),new Constant($b)); }
| name/a LE string/b { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_SMALLER_OR_EQUAL_THAN,new Identifier($a),new Constant($b)); }
| name/a LE num/b    { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_COMPARE_SMALLER_OR_EQUAL_THAN,new Identifier($a),new Constant($b)); }
| name/function '(' num/lat ',' num/long ',' num/radius ')' { /* TODO in radius function (ternary function)*/ }
.


selector = selectargument/arg { $$ = $1; }
| selector ',' selectargument/arg { $filters = array_merge($1["filters"],$3["filters"]); 
                                    $sorts = array_merge($1["sorts"],$3["sorts"]);
                                    $$ = array("filters"=>$filters,"sorts"=>$sorts); }
.

selectargument = argument/arg { $$ = array("filters" => array(new ColumnSelectionFilterColumn($arg,null)), "sorts" => array()); }
| argument/arg order { $$ = array( "filters" => array(new ColumnSelectionFilterColumn($arg,null)), "sorts" => array()); /* eens sort by functions bestaan, $$ = array() van twee arrays van argument, en een array van alle argumenten waarop moet gesorteerd worden */ }
| name ALIAS argument/arg  {$$ = array("filters" => array(new ColumnSelectionFilterColumn($arg,$1)), "sorts" => array());}
| name ALIAS argument/arg order {$$ = array("filters" => array(new ColumnSelectionFilterColumn($arg,$1)), "sorts" => array());}
.

function = name '(' argument ')' { $$ = createUnaryFunction($1,$3); }
| name '(' argument ',' argument ')' { $$ = createBinaryFunction($1,$3,$5); }
.

order = '+' { /* SORT BY ascending */ $$ = 1; }
| '-' { /* SORT BY descending  */ $$ = -1; }
.

argument = name/name { $$ = new Identifier($name); }
| link
| '*' { $$ = new Identifier('*'); }
| function { $$ = $1;}
.

link = name LN resourceid '.' name { /* joined resource */ }
.

format = name { /* do nothing, format isnt used in the AST for it is an abstract filter tree , format is not a filter.*/ }
.

calc = num { $$ = new Constant($1); }
| calc '+' calc { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_PLUS, $1, $3);  }
| calc '-' calc { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_MINUS, $1, $3); }
| calc '*' calc { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_MULTIPLY, $1, $3); }
| calc '/' calc { $$ = new BinaryFunction(BinaryFunction::$FUNCTION_BINARY_DIVIDE, $1, $3); }
| num '.' num { $$ = new Constant((double)($1 . "." . $3)); }
| '(' calc ')' {$$ = $1;} 
.